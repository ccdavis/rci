
//
// Testing out the impact of lots of function calls in the inner loop.
//  Swapping in sqr() for everywhere we mutiply a var by itself slows things
// down by about 10%. Not bad actually.

val x_resolution = 100;
val y_resolution = 132;

val max_iterations = 100;
val escape_radius = 2.0;


fun not_escaped(x:number, iy:number):boolean {
	return (sqr(x) + sqr(iy)) < 2*escape_radius; 	
}

// Check a point in the complex plane for membership
fun in_mandelbrot(c_x:number, c_iy:number):boolean {
	var iterations = 0;
	var zn_x = 0.0;
	var zn_iy = 0.0;
	
	var tmp_zx = 0.0;
	
	while iterations < max_iterations and not_escaped(zn_x, zn_iy) {
		//if iterations = max_iterations { 			
		//	return false;
		//}
				
		tmp_zx := c_x + (sqr(zn_x ) - sqr(zn_iy));
		zn_iy := c_iy + 2.0 * zn_x * zn_iy;    
		zn_x := tmp_zx;
		iterations := iterations + 1;
	}
	return iterations < max_iterations;
}

fun calc(x1:number, y1:number, x2:number, y2:number):number {
	var left:number = x1;
	val right:number = x2;
	var top:number = y1;
	val bottom:number = y2;
	
	val height:number = bottom - top;
	val width:number = right - left;
	val x_increment:number =width / x_resolution;
	val y_increment:number =height / y_resolution; 
	
	var points = 0;	
	
	while left < right {						
		val line:string = "";
		while top < bottom {
			if in_mandelbrot(left, top) {
				line := line + "*";
			} else {
				line := line + " ";
			}
			top := top + y_increment;
			points := points + 1;			
		}
		print line;
		top := y1;
		left := left + x_increment;
	}
	
	return points;
}

print "Starting";
val start:number = clock();
calc(-1.5, -1.0, 1.0, 1.0);
print "Timer:";
print clock() - start;
